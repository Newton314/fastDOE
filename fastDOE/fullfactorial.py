# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_fullfactorial.ipynb.

# %% auto 0
__all__ = ['fullfactorial', 'fullfactorial2k']

# %% ../02_fullfactorial.ipynb 2
import numpy as np
import pandas as pd

from numpy.random import default_rng

from .core import ExperimentalDesign

# %% ../02_fullfactorial.ipynb 4
def _generate_levels(factorlvls: list) -> list:
    """Generates a list of the levels from
    the given list with numbers of levels for each factor.

    [2, 3, 2] -> [[0, 1], [0, 1, 2], [0, 1]]

    Args:
        factorlvls (list): list with the number of levels for each factor

    Returns:
        list: list with the levels for each factor
    """
    levels = []
    for rnge in factorlvls:
        assert(type(rnge) == int)
        levels.append(list(range(rnge)))
    return levels

# %% ../02_fullfactorial.ipynb 6
def _build_ff_column(factor:int, nr_levels: list, levels: list) -> list:
    """Builds the experimental column for the given factor.

    Args:
        col (int): the column to build
        nr_levels (list): number of levels per factor e.g. [2, 3, 4]
        levels (list): level for each factor e.g. [[0, 1], [0, 1, 2, 3], [0, 1, 2, 3, 4]]

    Returns:
        list: column of the experimental design matrix for the given factor
    """
    lvls = [1, 1] + nr_levels
    n = np.array(nr_levels).prod()
    reps = lvls[factor] * lvls[factor +1]
    unit = []
    for i in levels[factor]:
        unit.extend([i] * reps)
    column = unit * int(n / len(unit))
    return column
   
    

# %% ../02_fullfactorial.ipynb 7
def fullfactorial(nr_lvls: list = [], levels: list = []) -> np.ndarray:
    """Generates a general fullfactorial experimental design matrix

    Args:
        factorlvls (list): _description_ e.g. [2, 3, 3]. Defaults to [].
        levels (list, optional): _description_. eg. [[1, 2], [1, 2, 3], [1, 2, 3]] Defaults to [].

    Returns:
        np.ndarray: _description_
    """
    if not nr_lvls and not levels:
        raise ValueError("Please provide either nr_lvls or levels.")
    nr_lvls = [len(x) for x in levels] if not nr_lvls else nr_lvls
    levels = _generate_levels(nr_lvls) if not levels else levels

    # build the design matrix
    matrix = []
    for i, lvl in enumerate(nr_lvls):
        matrix.append(_build_ff_column(i, nr_lvls, levels))
    matrix = np.array(matrix)
    return matrix.T
    

# %% ../02_fullfactorial.ipynb 10
def fullfactorial2k(k: int) -> np.ndarray:
    """
    Creates a full factorial design with 2 levels per factor
    in standard order

    if you have 5 or more factors consider screening designs
    to reduce the number of factors

    k (int): number of factors

    Return
    """
    nr_lvls = [2] * k
    levels = [[-1, 1] for _ in range(k)]
    return fullfactorial(nr_lvls, levels)


# %% ../02_fullfactorial.ipynb 15
def _randomize_frame(df: pd.DataFrame, randomize=True, axis: int=0, seed=42) -> pd.DataFrame:
    """Randomizes the rows of the Dataframe
    if randomize is True.

    Args:
        df (pd.DataFrame): _description_
        randomize (bool, optional): _description_. Defaults to True.
        axis (int, optional): _description_. Defaults to 0.
        seed (int, optional): _description_. Defaults to 42.

    Returns:
        pd.DataFrame: _description_
    """
    if randomize:
        rng = default_rng(seed)
        rng.shuffle(df.values, axis=axis)
    return df

# %% ../02_fullfactorial.ipynb 16
def _add_blocks(df: pd.DataFrame, block_on:str) -> pd.DataFrame:
    """Adds blocking to the given Dataframe
    for the given columns to block_on.

    Args:
        df (pd.DataFrame): _description_
        block_on (str): column which is used to block the experimental Design

    Returns:
        pd.DataFrame: _description_
    """
    i = 0
    if block_on == "rep":
        for r in df["rep"].unique():
            df.loc[(df["rep"]==r), "block"] = i
            i += 1
    elif block_on in df.columns:
        for r in df["rep"].unique():
            for v in df[block_on].unique():
                df.loc[(df["rep"]==r) & (df[block_on]==v), "block"] = i
                i+=1
    return df


# %% ../02_fullfactorial.ipynb 17
def _add_centerruns(matrix: pd.DataFrame, centerruns) -> pd.DataFrame:
    """Adds centerruns to  the given design matrix

    Args:
        matrix (pd.DataFrame): _description_
        centerruns (str | int): either "block" to add centerruns after each block
                                or specify the number of centerruns directly which
                                are distributed evenly across the design matrix

    Returns:
        pd.DataFrame: _description_
    """
    n = matrix.shape[0]
    if centerruns == "block":
        centerruns = len(matrix["block"].unique()) + 1
    elif type(centerruns) == int:
        centerruns = centerruns
    centerpositions = np.linspace(0, n, centerruns, dtype="int")
    new_matrix = np.insert(matrix.values, centerpositions, [0]*matrix.shape[1], axis=0)
    return pd.DataFrame(new_matrix, columns=matrix.columns)

